
#define CML_GRAY_RANGE       (CML_GRAY_MAX - CML_GRAY_MIN)
#define CML_GRAY_INVRANGE    (1.f / CML_GRAY_RANGE)

#define CML_XYZ_X_RANGE       (CML_XYZ_X_MAX - CML_XYZ_X_MIN)
#define CML_XYZ_X_INVRANGE    (1.f / CML_XYZ_X_RANGE)
#define CML_XYZ_Y_RANGE       (CML_XYZ_Y_MAX - CML_XYZ_Y_MIN)
#define CML_XYZ_Y_INVRANGE    (1.f / CML_XYZ_Y_RANGE)
#define CML_XYZ_Z_RANGE       (CML_XYZ_Z_MAX - CML_XYZ_Z_MIN)
#define CML_XYZ_Z_INVRANGE    (1.f / CML_XYZ_Z_RANGE)

#define CML_Yxy_Y_RANGE       (CML_Yxy_Y_MAX - CML_Yxy_Y_MIN)
#define CML_Yxy_Y_INVRANGE    (1.f / CML_Yxy_Y_RANGE)
#define CML_Yxy_x_RANGE       (CML_Yxy_x_MAX - CML_Yxy_x_MIN)
#define CML_Yxy_x_INVRANGE    (1.f / CML_Yxy_x_RANGE)
#define CML_Yxy_y_RANGE       (CML_Yxy_y_MAX - CML_Yxy_y_MIN)
#define CML_Yxy_y_INVRANGE    (1.f / CML_Yxy_y_RANGE)

#define CML_Yuv_Y_RANGE       (CML_Yuv_Y_MAX - CML_Yuv_Y_MIN)
#define CML_Yuv_Y_INVRANGE    (1.f / CML_Yuv_Y_RANGE)
#define CML_Yuv_u_RANGE       (CML_Yuv_u_MAX - CML_Yuv_u_MIN)
#define CML_Yuv_u_INVRANGE    (1.f / CML_Yuv_u_RANGE)
#define CML_Yuv_v_RANGE       (CML_Yuv_v_MAX - CML_Yuv_v_MIN)
#define CML_Yuv_v_INVRANGE    (1.f / CML_Yuv_v_RANGE)

#define CML_Yupvp_Y_RANGE     (CML_Yupvp_Y_MAX - CML_Yupvp_Y_MIN)
#define CML_Yupvp_Y_INVRANGE  (1.f / CML_Yupvp_Y_RANGE)
#define CML_Yupvp_up_RANGE    (CML_Yupvp_up_MAX - CML_Yupvp_up_MIN)
#define CML_Yupvp_up_INVRANGE (1.f / CML_Yupvp_vp_RANGE)
#define CML_Yupvp_vp_RANGE    (CML_Yupvp_vp_MAX - CML_Yupvp_vp_MIN)
#define CML_Yupvp_vp_INVRANGE (1.f / CML_Yupvp_up_RANGE)

#define CML_Ycd_Y_RANGE       (CML_Ycd_Y_MAX - CML_Ycd_Y_MIN)
#define CML_Ycd_Y_INVRANGE    (1.f / CML_Ycd_Y_RANGE)
#define CML_Ycd_c_RANGE       (CML_Ycd_c_MAX - CML_Ycd_c_MIN)
#define CML_Ycd_c_INVRANGE    (1.f / CML_Ycd_c_RANGE)
#define CML_Ycd_d_RANGE       (CML_Ycd_d_MAX - CML_Ycd_d_MIN)
#define CML_Ycd_d_INVRANGE    (1.f / CML_Ycd_d_RANGE)

#define CML_Lab_L_RANGE       (CML_Lab_L_MAX - CML_Lab_L_MIN)
#define CML_Lab_L_INVRANGE    (1.f / CML_Lab_L_RANGE)
#define CML_Lab_a_RANGE       (CML_Lab_a_MAX - CML_Lab_a_MIN)
#define CML_Lab_a_INVRANGE    (1.f / CML_Lab_a_RANGE)
#define CML_Lab_b_RANGE       (CML_Lab_b_MAX - CML_Lab_b_MIN)
#define CML_Lab_b_INVRANGE    (1.f / CML_Lab_b_RANGE)

#define CML_Lch_L_RANGE       (CML_Lch_L_MAX - CML_Lch_L_MIN)
#define CML_Lch_L_INVRANGE    (1.f / CML_Lch_L_RANGE)
#define CML_Lch_c_RANGE       (CML_Lch_c_MAX - CML_Lch_c_MIN)
#define CML_Lch_c_INVRANGE    (1.f / CML_Lch_c_RANGE)
#define CML_Lch_h_RANGE       (CML_Lch_h_MAX - CML_Lch_h_MIN)
#define CML_Lch_h_INVRANGE    (1.f / CML_Lch_h_RANGE)

#define CML_Luv_L_RANGE       (CML_Luv_L_MAX - CML_Luv_L_MIN)
#define CML_Luv_L_INVRANGE    (1.f / CML_Luv_L_RANGE)
#define CML_Luv_u_RANGE       (CML_Luv_u_MAX - CML_Luv_u_MIN)
#define CML_Luv_u_INVRANGE    (1.f / CML_Luv_u_RANGE)
#define CML_Luv_v_RANGE       (CML_Luv_v_MAX - CML_Luv_v_MIN)
#define CML_Luv_v_INVRANGE    (1.f / CML_Luv_v_RANGE)

#define CML_RGB_R_RANGE       (CML_RGB_R_MAX - CML_RGB_R_MIN)
#define CML_RGB_R_INVRANGE    (1.f / CML_RGB_R_RANGE)
#define CML_RGB_G_RANGE       (CML_RGB_G_MAX - CML_RGB_G_MIN)
#define CML_RGB_G_INVRANGE    (1.f / CML_RGB_G_RANGE)
#define CML_RGB_B_RANGE       (CML_RGB_B_MAX - CML_RGB_B_MIN)
#define CML_RGB_B_INVRANGE    (1.f / CML_RGB_B_RANGE)

#define CML_YCbCr_Y_RANGE     (CML_YCbCr_Y_MAX - CML_YCbCr_Y_MIN)
#define CML_YCbCr_Y_INVRANGE  (1.f / CML_YCbCr_Y_RANGE)
#define CML_YCbCr_Cb_RANGE    (CML_YCbCr_Cb_MAX - CML_YCbCr_Cb_MIN)
#define CML_YCbCr_Cb_INVRANGE (1.f / CML_YCbCr_Cb_RANGE)
#define CML_YCbCr_Cr_RANGE    (CML_YCbCr_Cr_MAX - CML_YCbCr_Cr_MIN)
#define CML_YCbCr_Cr_INVRANGE (1.f / CML_YCbCr_Cr_RANGE)

#define CML_HSV_H_RANGE       (CML_HSV_H_MAX - CML_HSV_H_MIN)
#define CML_HSV_H_INVRANGE    (1.f / CML_HSV_H_RANGE)
#define CML_HSV_S_RANGE       (CML_HSV_S_MAX - CML_HSV_S_MIN)
#define CML_HSV_S_INVRANGE    (1.f / CML_HSV_S_RANGE)
#define CML_HSV_V_RANGE       (CML_HSV_V_MAX - CML_HSV_V_MIN)
#define CML_HSV_V_INVRANGE    (1.f / CML_HSV_V_RANGE)

#define CML_HSL_H_RANGE       (CML_HSL_H_MAX - CML_HSL_H_MIN)
#define CML_HSL_H_INVRANGE    (1.f / CML_HSL_H_RANGE)
#define CML_HSL_S_RANGE       (CML_HSL_S_MAX - CML_HSL_S_MIN)
#define CML_HSL_S_INVRANGE    (1.f / CML_HSL_S_RANGE)
#define CML_HSL_L_RANGE       (CML_HSL_L_MAX - CML_HSL_L_MIN)
#define CML_HSL_L_INVRANGE    (1.f / CML_HSL_L_RANGE)

#define CML_CMYK_C_RANGE       (CML_CMYK_C_MAX - CML_CMYK_C_MIN)
#define CML_CMYK_C_INVRANGE    (1.f / CML_CMYK_C_RANGE)
#define CML_CMYK_M_RANGE       (CML_CMYK_M_MAX - CML_CMYK_M_MIN)
#define CML_CMYK_M_INVRANGE    (1.f / CML_CMYK_M_RANGE)
#define CML_CMYK_Y_RANGE       (CML_CMYK_Y_MAX - CML_CMYK_Y_MIN)
#define CML_CMYK_Y_INVRANGE    (1.f / CML_CMYK_Y_RANGE)
#define CML_CMYK_K_RANGE       (CML_CMYK_K_MAX - CML_CMYK_K_MIN)
#define CML_CMYK_K_INVRANGE    (1.f / CML_CMYK_K_RANGE)



// //////////////////////////
// float Input Conversions from normed range (0,1)
// //////////////////////////

// Warning if a genius developer stumbles here and thinks that it may be a
// good idea to enhance this implementation by default with offset and range:
// It's not a good idea.  The compiler can not optimize this.

CML_HIDEF void cml_OneNormedInputToCMYK(float* CML_RESTRICT cmyk, const float* CML_RESTRICT input){
  cmyk[0] = CML_CMYK_C_MIN    + input[0] * CML_CMYK_C_RANGE;
  cmyk[1] = CML_CMYK_M_MIN    + input[1] * CML_CMYK_M_RANGE;
  cmyk[2] = CML_CMYK_Y_MIN    + input[2] * CML_CMYK_Y_RANGE;
  cmyk[3] = CML_CMYK_K_MIN    + input[3] * CML_CMYK_K_RANGE;
}

CML_HIDEF void cml_OneNormedInputToGray(float* CML_RESTRICT gray, const float* CML_RESTRICT input){
  gray[0] = CML_GRAY_MIN      + input[0] * CML_GRAY_RANGE;
}

CML_HIDEF void cml_OneNormedInputToHSL(float* CML_RESTRICT hsl, const float* CML_RESTRICT input){
  hsl[0] = CML_HSL_H_MIN      + input[0] * CML_HSL_H_RANGE;
  hsl[1] = CML_HSL_S_MIN      + input[1] * CML_HSL_S_RANGE;
  hsl[2] = CML_HSL_L_MIN      + input[2] * CML_HSL_L_RANGE;
}

CML_HIDEF void cml_OneNormedInputToHSV(float* CML_RESTRICT hsv, const float* CML_RESTRICT input){
  hsv[0] = CML_HSV_H_MIN      + input[0] * CML_HSV_H_RANGE;
  hsv[1] = CML_HSV_S_MIN      + input[1] * CML_HSV_S_RANGE;
  hsv[2] = CML_HSV_V_MIN      + input[2] * CML_HSV_V_RANGE;
}

CML_HIDEF void cml_OneNormedInputToLab(float* CML_RESTRICT lab, const float* CML_RESTRICT input){
  lab[0] = CML_Lab_L_MIN      + input[0] * CML_Lab_L_RANGE;
  lab[1] = CML_Lab_a_MIN      + input[1] * CML_Lab_a_RANGE;
  lab[2] = CML_Lab_b_MIN      + input[2] * CML_Lab_b_RANGE;
}

CML_HIDEF void cml_OneNormedInputToLch(float* CML_RESTRICT lch, const float* CML_RESTRICT input){
  lch[0] = CML_Lch_L_MIN      + input[0] * CML_Lch_L_RANGE;
  lch[1] = CML_Lch_c_MIN      + input[1] * CML_Lch_c_RANGE;
  lch[2] = CML_Lch_h_MIN      + input[2] * CML_Lch_h_RANGE;
}

CML_HIDEF void cml_OneNormedInputToLuv(float* CML_RESTRICT luv, const float* CML_RESTRICT input){
  luv[0] = CML_Luv_L_MIN      + input[0] * CML_Luv_L_RANGE;
  luv[1] = CML_Luv_u_MIN      + input[1] * CML_Luv_u_RANGE;
  luv[2] = CML_Luv_v_MIN      + input[2] * CML_Luv_v_RANGE;
}

CML_HIDEF void cml_OneNormedInputToRGB(float* CML_RESTRICT rgb, const float* CML_RESTRICT input){
  rgb[0] = CML_RGB_R_MIN      + input[0] * CML_RGB_R_RANGE;
  rgb[1] = CML_RGB_G_MIN      + input[1] * CML_RGB_G_RANGE;
  rgb[2] = CML_RGB_B_MIN      + input[2] * CML_RGB_B_RANGE;
}

CML_HIDEF void cml_OneNormedInputToXYZ(float* CML_RESTRICT xyz, const float* CML_RESTRICT input){
  xyz[0] = CML_XYZ_X_MIN      + input[0] * CML_XYZ_X_RANGE;
  xyz[1] = CML_XYZ_Y_MIN      + input[1] * CML_XYZ_Y_RANGE;
  xyz[2] = CML_XYZ_Z_MIN      + input[2] * CML_XYZ_Z_RANGE;
}

CML_HIDEF void cml_OneNormedInputToYCbCr(float* CML_RESTRICT ycbcr, const float* CML_RESTRICT input){
  ycbcr[0] = CML_YCbCr_Y_MIN  + input[0] * CML_YCbCr_Y_RANGE;
  ycbcr[1] = CML_YCbCr_Cb_MIN + input[1] * CML_YCbCr_Cb_RANGE;
  ycbcr[2] = CML_YCbCr_Cr_MIN + input[2] * CML_YCbCr_Cr_RANGE;
}

CML_HIDEF void cml_OneNormedInputToYcd(float* CML_RESTRICT ycd, const float* CML_RESTRICT input){
  ycd[0] = CML_Ycd_Y_MIN      + input[0] * CML_Ycd_Y_RANGE;
  ycd[1] = CML_Ycd_c_MIN      + input[1] * CML_Ycd_c_RANGE;
  ycd[2] = CML_Ycd_d_MIN      + input[2] * CML_Ycd_d_RANGE;
}

CML_HIDEF void cml_OneNormedInputToYupvp(float* CML_RESTRICT yupvp, const float* CML_RESTRICT input){
  yupvp[0] = CML_Yupvp_Y_MIN  + input[0] * CML_Yupvp_Y_RANGE;
  yupvp[1] = CML_Yupvp_up_MIN + input[1] * CML_Yupvp_up_RANGE;
  yupvp[2] = CML_Yupvp_vp_MIN + input[2] * CML_Yupvp_vp_RANGE;
}

CML_HIDEF void cml_OneNormedInputToYuv(float* CML_RESTRICT yuv, const float* CML_RESTRICT input){
  yuv[0] = CML_Yuv_Y_MIN      + input[0] * CML_Yuv_Y_RANGE;
  yuv[1] = CML_Yuv_u_MIN      + input[1] * CML_Yuv_u_RANGE;
  yuv[2] = CML_Yuv_v_MIN      + input[2] * CML_Yuv_v_RANGE;
}

CML_HIDEF void cml_OneNormedInputToYxy(float* CML_RESTRICT yxy, const float* CML_RESTRICT input){
  yxy[0] = CML_Yxy_Y_MIN      + input[0] * CML_Yxy_Y_RANGE;
  yxy[1] = CML_Yxy_x_MIN      + input[1] * CML_Yxy_x_RANGE;
  yxy[2] = CML_Yxy_y_MIN      + input[2] * CML_Yxy_y_RANGE;
}





// //////////////////////////
// Output Conversions to normed range (0,1)
// //////////////////////////

CML_HIDEF void cml_OneCMYKToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT cmyk){
  output[0] = (cmyk[0] - CML_CMYK_C_MIN) * CML_CMYK_C_INVRANGE;
  output[1] = (cmyk[1] - CML_CMYK_M_MIN) * CML_CMYK_M_INVRANGE;
  output[2] = (cmyk[2] - CML_CMYK_Y_MIN) * CML_CMYK_Y_INVRANGE;
  output[3] = (cmyk[3] - CML_CMYK_K_MIN) * CML_CMYK_K_INVRANGE;
}

CML_HIDEF void cml_OneGrayToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT gray){
  output[0] = (gray[0] - CML_GRAY_MIN) * CML_GRAY_INVRANGE;
}

CML_HIDEF void cml_OneHSLToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT hsl){
  output[0] =  (hsl[0] - CML_HSL_H_MIN) * CML_HSL_H_INVRANGE;
  output[1] =  (hsl[1] - CML_HSL_S_MIN) * CML_HSL_S_INVRANGE;
  output[2] =  (hsl[2] - CML_HSL_L_MIN) * CML_HSL_L_INVRANGE;
}

CML_HIDEF void cml_OneHSVToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT hsv){
  output[0] =  (hsv[0] - CML_HSV_H_MIN) * CML_HSV_H_INVRANGE;
  output[1] =  (hsv[1] - CML_HSV_S_MIN) * CML_HSV_S_INVRANGE;
  output[2] =  (hsv[2] - CML_HSV_V_MIN) * CML_HSV_V_INVRANGE;
}

CML_HIDEF void cml_OneLabToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT lab){
  output[0] = (lab[0] - CML_Lab_L_MIN) * CML_Lab_L_INVRANGE;
  output[1] = (lab[1] - CML_Lab_a_MIN) * CML_Lab_a_INVRANGE;
  output[2] = (lab[2] - CML_Lab_b_MIN) * CML_Lab_b_INVRANGE;
}

CML_HIDEF void cml_OneLchToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT lch){
  output[0] = (lch[0] - CML_Lch_L_MIN) * CML_Lch_L_INVRANGE;
  output[1] = (lch[1] - CML_Lch_c_MIN) * CML_Lch_c_INVRANGE;
  output[2] = (lch[2] - CML_Lch_h_MIN) * CML_Lch_h_INVRANGE;
}

CML_HIDEF void cml_OneLuvToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT luv){
  output[0] = (luv[0] - CML_Luv_L_MIN) * CML_Luv_L_INVRANGE;
  output[1] = (luv[1] - CML_Luv_u_MIN) * CML_Luv_u_INVRANGE;
  output[2] = (luv[2] - CML_Luv_v_MIN) * CML_Luv_v_INVRANGE;
}

CML_HIDEF void cml_OneRGBToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT rgb){
  output[0] = (rgb[0] - CML_RGB_R_MIN) * CML_RGB_R_INVRANGE;
  output[1] = (rgb[1] - CML_RGB_G_MIN) * CML_RGB_G_INVRANGE;
  output[2] = (rgb[2] - CML_RGB_B_MIN) * CML_RGB_B_INVRANGE;
}

CML_HIDEF void cml_OneXYZToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT xyz){
  output[0] = (xyz[0] - CML_XYZ_X_MIN) * CML_XYZ_X_INVRANGE;
  output[1] = (xyz[1] - CML_XYZ_Y_MIN) * CML_XYZ_Y_INVRANGE;
  output[2] = (xyz[2] - CML_XYZ_Z_MIN) * CML_XYZ_Z_INVRANGE;
}

CML_HIDEF void cml_OneYCbCrToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT ycbcr){
  output[0] = (ycbcr[0] - CML_YCbCr_Y_MIN) * CML_YCbCr_Y_INVRANGE;
  output[1] = (ycbcr[1] - CML_YCbCr_Cb_MIN) * CML_YCbCr_Cb_INVRANGE;
  output[2] = (ycbcr[2] - CML_YCbCr_Cr_MIN) * CML_YCbCr_Cr_INVRANGE;
}

CML_HIDEF void cml_OneYcdToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT ycd){
  output[0] = (ycd[0] - CML_Ycd_Y_MIN) * CML_Ycd_Y_INVRANGE;
  output[1] = (ycd[1] - CML_Ycd_c_MIN) * CML_Ycd_c_INVRANGE;
  output[2] = (ycd[2] - CML_Ycd_d_MIN) * CML_Ycd_d_INVRANGE;
}

CML_HIDEF void cml_OneYupvpToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT yupvp){
  output[0] = (yupvp[0] - CML_Yupvp_Y_MIN) * CML_Yupvp_Y_INVRANGE;
  output[1] = (yupvp[1] - CML_Yupvp_up_MIN) * CML_Yupvp_up_INVRANGE;
  output[2] = (yupvp[2] - CML_Yupvp_vp_MIN) * CML_Yupvp_vp_INVRANGE;
}

CML_HIDEF void cml_OneYuvToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT yuv){
  output[0] = (yuv[0] - CML_Yuv_Y_MIN) * CML_Yuv_Y_INVRANGE;
  output[1] = (yuv[1] - CML_Yuv_u_MIN) * CML_Yuv_u_INVRANGE;
  output[2] = (yuv[2] - CML_Yuv_v_MIN) * CML_Yuv_v_INVRANGE;
}

CML_HIDEF void cml_OneYxyToNormedOutput(float* CML_RESTRICT output, const float* CML_RESTRICT yxy){
  output[0] = (yxy[0] - CML_Yxy_Y_MIN) * CML_Yxy_Y_INVRANGE;
  output[1] = (yxy[1] - CML_Yxy_x_MIN) * CML_Yxy_x_INVRANGE;
  output[2] = (yxy[2] - CML_Yxy_y_MIN) * CML_Yxy_y_INVRANGE;
}




// /////////////////////////////////////
// Normed Cartesian methods
// /////////////////////////////////////

CML_HIDEF void cml_OneNormedCartesianInputToHSL(float* CML_RESTRICT hsl, const float* CML_RESTRICT input){
  float vec[2] = {input[0] * 2.f - 1.f, input[1] * 2.f - 1.f};
  cmlCartesianToPolar(&(hsl[1]), vec);
  hsl[0] = cmlRadToDeg(hsl[2]);
  if(hsl[0] < 0.f){hsl[0] += 360.f;}
  hsl[1] = hsl[1];
  hsl[2] = input[2];
}

CML_HIDEF void cml_OneNormedCartesianInputToHSV(float* CML_RESTRICT hsv, const float* CML_RESTRICT input){
  float vec[2] = {input[0] * 2.f - 1.f, input[1] * 2.f - 1.f};
  cmlCartesianToPolar(&(hsv[1]), vec);
  hsv[0] = cmlRadToDeg(hsv[2]);
  if(hsv[0] < 0.f){hsv[0] += 360.f;}
  hsv[1] = hsv[1];
  hsv[2] = input[2];
}

CML_HIDEF void cml_OneNormedCartesianInputToLch(float* CML_RESTRICT lch, const float* CML_RESTRICT input){
  float vec[2] = {input[1] * 2.f - 1.f, input[2] * 2.f - 1.f};
  lch[0] = input[0] * CML_Lch_L_RANGE;
  cmlCartesianToPolar(&(lch[1]), vec);
  lch[1] *= CML_Lch_c_RANGE;
  lch[2] = cmlRadToDeg(lch[2]);
  if(lch[2] < 0.f){lch[2] += 360.f;}
}



CML_HIDEF void cml_OneHSLToNormedCartesianOutput(float* CML_RESTRICT output, const float* CML_RESTRICT hsl){
  float vec[2] = {hsl[1], cmlDegToRad(hsl[0])};
  cmlPolarToCartesian(&(output[0]), vec);
  output[0] = .5f * (output[0] + 1.f);
  output[1] = .5f * (output[1] + 1.f);
  output[2] = hsl[2];
}

CML_HIDEF void cml_OneHSVToNormedCartesianOutput(float* CML_RESTRICT output, const float* CML_RESTRICT hsv){
  float vec[2] = {hsv[1], cmlDegToRad(hsv[0])};
  cmlPolarToCartesian(&(output[0]), vec);
  output[0] = .5f * (output[0] + 1.f);
  output[1] = .5f * (output[1] + 1.f);
  output[2] = hsv[2];
}

CML_HIDEF void cml_OneLchToNormedCartesianOutput(float* CML_RESTRICT output, const float* CML_RESTRICT lch){
  float vec[2] = {lch[1] * CML_Lch_c_INVRANGE, cmlDegToRad(lch[2])};
  output[0] = lch[0] * CML_Lch_L_INVRANGE;
  cmlPolarToCartesian(&(output[1]), vec);
  output[1] = .5f * (output[1] + 1.f);
  output[2] = .5f * (output[2] + 1.f);
}



// This is free and unencumbered software released into the public domain.

// Anyone is free to copy, modify, publish, use, compile, sell, or
// distribute this software, either in source code form or as a compiled
// binary, for any purpose, commercial or non-commercial, and by any
// means.

// In jurisdictions that recognize copyright laws, the author or authors
// of this software dedicate any and all copyright interest in the
// software to the public domain. We make this dedication for the benefit
// of the public at large and to the detriment of our heirs and
// successors. We intend this dedication to be an overt act of
// relinquishment in perpetuity of all present and future rights to this
// software under copyright law.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.

// For more information, please refer to <http://unlicense.org/>

